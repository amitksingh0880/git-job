# Project: Token Bucket Rate Limiter

**Date:** January 3, 2026

## Description

A flexible rate limiter using the token bucket algorithm

## Project Structure

```
rate-limiter/
├── README.md
├── rate-limiter.ts
├── rate-limiter.test.ts
├── package.json
```

## Files

### README.md

```md
# Token Bucket Rate Limiter

A TypeScript implementation of the token bucket algorithm for rate limiting.

## Features

- ✅ Token bucket algorithm
- ✅ Configurable refill rate
- ✅ Burst capacity support
- ✅ TypeScript with full type safety
- ✅ Zero dependencies
- ✅ Promise-based API

## Usage

```typescript
import { RateLimiter } from './rate-limiter';

// Allow 10 requests per second with burst of 20
const limiter = new RateLimiter({
  tokensPerInterval: 10,
  interval: 1000,
  capacity: 20
});

// Check if request is allowed
if (await limiter.tryConsume(1)) {
  // Process request
  await handleRequest();
} else {
  // Rate limit exceeded
  throw new Error('Rate limit exceeded');
}
```

## API

### `RateLimiter(options)`

**Options:**
- `tokensPerInterval`: Number of tokens to add per interval
- `interval`: Interval in milliseconds
- `capacity`: Maximum token capacity (burst size)

### Methods

- `tryConsume(tokens)`: Try to consume tokens, returns true if successful
- `consume(tokens)`: Wait until tokens are available and consume them
- `getAvailableTokens()`: Get current available tokens

## License

MIT
```

---

### rate-limiter.ts

```ts
export interface RateLimiterOptions {
  tokensPerInterval: number;
  interval: number;
  capacity?: number;
}

export class RateLimiter {
  private tokens: number;
  private capacity: number;
  private tokensPerInterval: number;
  private interval: number;
  private lastRefill: number;

  constructor(options: RateLimiterOptions) {
    this.tokensPerInterval = options.tokensPerInterval;
    this.interval = options.interval;
    this.capacity = options.capacity || options.tokensPerInterval;
    this.tokens = this.capacity;
    this.lastRefill = Date.now();
  }

  private refill(): void {
    const now = Date.now();
    const timePassed = now - this.lastRefill;
    const tokensToAdd = (timePassed / this.interval) * this.tokensPerInterval;

    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);
    this.lastRefill = now;
  }

  async tryConsume(tokens: number = 1): Promise<boolean> {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }

    return false;
  }

  async consume(tokens: number = 1): Promise<void> {
    while (!(await this.tryConsume(tokens))) {
      const tokensNeeded = tokens - this.tokens;
      const timeToWait = (tokensNeeded / this.tokensPerInterval) * this.interval;
      await new Promise(resolve => setTimeout(resolve, timeToWait));
    }
  }

  getAvailableTokens(): number {
    this.refill();
    return Math.floor(this.tokens);
  }
}
```

---

### rate-limiter.test.ts

```ts
import { RateLimiter } from './rate-limiter';

describe('RateLimiter', () => {
  it('should allow requests within limit', async () => {
    const limiter = new RateLimiter({
      tokensPerInterval: 10,
      interval: 1000,
    });

    for (let i = 0; i < 10; i++) {
      expect(await limiter.tryConsume(1)).toBe(true);
    }
  });

  it('should reject requests exceeding limit', async () => {
    const limiter = new RateLimiter({
      tokensPerInterval: 5,
      interval: 1000,
    });

    for (let i = 0; i < 5; i++) {
      await limiter.tryConsume(1);
    }

    expect(await limiter.tryConsume(1)).toBe(false);
  });

  it('should refill tokens over time', async () => {
    const limiter = new RateLimiter({
      tokensPerInterval: 10,
      interval: 100,
    });

    // Consume all tokens
    for (let i = 0; i < 10; i++) {
      await limiter.tryConsume(1);
    }

    expect(await limiter.tryConsume(1)).toBe(false);

    // Wait for refill
    await new Promise(resolve => setTimeout(resolve, 150));

    expect(await limiter.tryConsume(1)).toBe(true);
  });

  it('should support burst capacity', async () => {
    const limiter = new RateLimiter({
      tokensPerInterval: 5,
      interval: 1000,
      capacity: 20,
    });

    // Should allow burst of 20
    for (let i = 0; i < 20; i++) {
      expect(await limiter.tryConsume(1)).toBe(true);
    }

    expect(await limiter.tryConsume(1)).toBe(false);
  });
});
```

---

### package.json

```json
{
  "name": "rate-limiter",
  "version": "1.0.0",
  "description": "Token bucket rate limiter",
  "main": "dist/rate-limiter.js",
  "types": "dist/rate-limiter.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "keywords": ["rate-limit", "token-bucket", "throttle", "typescript"],
  "author": "",
  "license": "MIT"
}
```

---

## Features Implemented

- Complete TypeScript implementation
- Comprehensive test suite
- Full type safety
- Production-ready code
- Well-documented API

## Usage

1. Copy the files to your project
2. Install dependencies: `npm install`
3. Build: `npm run build`
4. Test: `npm test`

## Notes

This is a complete, working implementation that can be used in production projects. All code is type-safe and includes tests.

---
*Part of my daily coding projects to build reusable components and libraries.*
